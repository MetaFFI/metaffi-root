import re
from typing import Tuple
import os
import SCons.Script
import SCons.Node.FS
from SCons.Environment import Environment
import sys
import glob
import subprocess
import compiler_options
import post_actions
from typing import *

def verify_metaffi_home() -> Tuple[bool, str]:
	if 'METAFFI_HOME' not in os.environ:
		msg = 'METAFFI_HOME environment variable is not set.'
		msg += 'Set METAFFI_HOME to where you want MetaFFI to be installed.'
		return False, msg

	metaffi_home = os.environ['METAFFI_HOME']
	if not os.path.exists(metaffi_home):
		try:
			os.makedirs(metaffi_home)
		except Exception as e:
			return False, f'Failed to create METAFFI_HOME: {e}'
			
	return True, None

def WhereWithError(env: Environment, cmd: str) -> Tuple[bool, str]:
	if not env.WhereIs(cmd):
		path = env['ENV']['PATH'].split(os.path.pathsep)
		msg = f'{cmd} is not installed.\nSCons PATH: {path}'
		return False, msg
	
	return True, None


def LoadConanPackagesInfo(env: Environment):
	# if current directory (based on current __FILE__ location) doesn't have conanfile.txt, raise an error that the current directory has no conanfile.txt
	if not env.Dir('.').File('conanfile.txt').exists():
		expected_file_location = env.Dir('.').File('conanfile.txt').abspath
		print(f'{expected_file_location} not found in the current directory. Exiting...', file=sys.stderr)
		env.Exit(1)

	# if SConscript_conandeps doesn't exist, run 'conan install . --build=missing' and delete generated batch files
	# make sure not to delete batch files that were generated by the user
	if not os.path.exists(env.Dir('.').File('SConscript_conandeps').abspath):
		# get all existing batch files
		# run 'conan install . --build=missing'
		# delete all the batch files generated by conan, but make sure not to delete the batch files that were generated by the user
		
		# get all existing batch files before installing
		batch_files_before = glob.glob(os.path.join(env.Dir('.').abspath, '*.bat'))

		print('Running conan install . --build=missing')
		process = subprocess.run('conan install . --build=missing', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		# Print stdout and stderr
		print(process.stdout.decode())
		print(process.stderr.decode(), file=sys.stderr)

		if process.returncode != 0:
			print('Failed to run conan install. Exiting...', file=sys.stderr)
			env.Exit(1)

		# delete all batch files that don't exist in batch_files_before
		batch_files_after = glob.glob(os.path.join(env.Dir('.').abspath, '*.bat'))
		for batch_file in batch_files_after:
			if batch_file not in batch_files_before:
				os.remove(batch_file)

		# make sure that SConscript_conandeps is created
		if not os.path.exists(env.Dir('.').File('SConscript_conandeps').abspath):
			print('Failed to create SConscript_conandeps. Exiting...', file=sys.stderr)
			env.Exit(1)

	conan_info = SCons.Script.SConscript('SConscript_conandeps')
	env['conan_info'] = conan_info

	# load CPPDEFINES, CPPFLAGS, CPPPATH, LIBS, LIBPATH from conan_info
	env.Append(CPPDEFINES=env['conan_info']['conandeps'].get('CPPDEFINES', []))
	env.Append(CPPFLAGS=env['conan_info']['conandeps'].get('CPPFLAGS', []))
	env.Append(CPPPATH=env['conan_info']['conandeps'].get('CPPPATH', []))
	env.Append(LIBS=env['conan_info']['conandeps'].get('LIBS', []))
	env.Append(LIBPATH=env['conan_info']['conandeps'].get('LIBPATH', []))


def CPPDynamicLibrary(env: Environment, target: str, project_name: str, sources: List[str], include_dirs: List[str]|None = None, lib_dirs: List[str]|None = None, libs: List[str]|None = None) -> SCons.Node.NodeList:
	if 'release' in env['BUILD_TYPE']:
		options = compiler_options.default_release_compiler_options(env)
	elif 'debug' in env['BUILD_TYPE']:
		options = compiler_options.default_debug_compiler_options(env)
	elif 'release_debug_info' in env['BUILD_TYPE']:
		options = compiler_options.default_release_with_debug_info_compiler_options(env)
	else:
		print(f'Unknown BUILD_TYPE: {env["BUILD_TYPE"]}. Exiting...', file=sys.stderr)
		env.Exit(1)

	if include_dirs is not None:
		options.set_include_directories(include_dirs)

	if lib_dirs is not None:
		options.set_lib_directories(lib_dirs)

	if libs is not None:
		options.add_library(libs)
	
	options.set_output_directories(project_name, target)

	# if non-windows, just compile the shared object,
	# in windows, create object files, extract their symbols, make a def file, and then create the shared object
	if env['PLATFORM'] != 'win32':
		return env.SharedLibrary(target=env['OUTPUT_BIN'], source=sources)
	else:
		# CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS implementation
		# extract symbols from object files
		def extract_symbols(target, source, env):

			# make sure that dumpbin is found
			if not env.WhereIs('dumpbin'):
				print('dumpbin.exe is not found. Exiting...', file=sys.stderr)
				env.Exit(1)
			
			# use dumpbin to extract symbols from object files
			object_files = [str(s.abspath) for s in source]
			symbols = []
			for object_file in object_files:
				try:
					process = subprocess.run([env.WhereIs('dumpbin'), '/SYMBOLS', object_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
					if process.returncode != 0:
						print(f'Failed to extract symbols from {object_file}. Exiting...', file=sys.stderr)
						env.Exit(1)
					# parse output and append to symbols list - make sure to append only the symbol name
					output = process.stdout.decode()
					# Adjust the regex pattern based on the actual format of the dumpbin output
					pattern = r'[0-9A-Fa-f]{3} [0-9A-Fa-f]{8} (.{5}) .*(External|Public).*\| ([^\s]+)'
					matches = re.finditer(pattern, output, re.MULTILINE)
					for match in matches:
						if 'UNDEF' not in match.group(0):
							symbol = match.group(3).strip()
							symbols.append(symbol)
				except Exception as e:
					print(f'Failed to extract symbols from {object_file}.\nError {e}.\nExiting...', file=sys.stderr)
					env.Exit(1)

			# make sure all symbols are unique by converting to set and back to list
			symbols = list(set(symbols))

			# write symbols list to a .def file named as [target].def
			with open(target[0].abspath, 'w') as f:
				f.write('EXPORTS\n')
				for symbol in symbols:
					f.write('\t' + symbol + '\n')

		# compile object files
		object_files = env.Object(sources)
		
		# extract symbols
		symbols_file = env.Command(target=env['OUTPUT_BIN'] + '.def', source=object_files, action=extract_symbols)
		# always run extract symbols command, even if the def file exists
		# env.AlwaysBuild(symbols_file)

		# symbols_files is dependent on object_files
		env.Depends(symbols_file, object_files)
		# create shared object
		
		env.setdefault('SHLINKFLAGS', []).append('/DEF:'+env['OUTPUT_BIN']+'.def')
		env['SHLINKFLAGS'].append('/DLL')

		dll = env.SharedLibrary(target=env['OUTPUT_BIN'], source=object_files, SHLIBPREFIX='', SHLIBSUFFIX='.dll')
		env.Depends(dll, symbols_file)
		return dll


def CPPProgram(env: Environment, target: str, project_name: str, sources: List[str], include_dirs: List[str]|None = None, lib_dirs: List[str]|None = None, libs: List[str]|None = None) -> SCons.Node.NodeList:
	if 'release' in env['BUILD_TYPE']:
		options = compiler_options.default_release_compiler_options(env)
	elif 'debug' in env['BUILD_TYPE']:
		options = compiler_options.default_debug_compiler_options(env)
	elif 'release_debug_info' in env['BUILD_TYPE']:
		options = compiler_options.default_release_with_debug_info_compiler_options(env)
	else:
		print(f'Unknown BUILD_TYPE: {env["BUILD_TYPE"]}. Exiting...', file=sys.stderr)
		env.Exit(1)

	if include_dirs is not None:
		options.set_include_directories(include_dirs)
	
	if lib_dirs is not None:
		options.set_lib_directories(lib_dirs)

	if libs is not None:
		options.add_library(libs)
	
	options.set_output_directories(project_name, target)

	return env.Program(target=env['OUTPUT_BIN'], source=sources)


def GoTest(env: Environment, target: str, path: str) -> SCons.Node.NodeList:
	return env.Command(target=target, source=[], action=post_actions.execute_go_unitest, chdir=path)

def add_custom_methods(env: Environment):
	env.AddMethod(WhereWithError, 'WhereWithError')
	env.AddMethod(LoadConanPackagesInfo, 'LoadConanPackagesInfo')
	env.AddMethod(CPPProgram, 'CPPProgram')
	env.AddMethod(GoTest, 'GoTest')
	env.AddMethod(CPPDynamicLibrary, 'CPPDynamicLibrary')
	